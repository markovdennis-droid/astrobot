# bot.py
# -*- coding: utf-8 -*-
"""
ASTROBOT ‚Äî —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è (aiogram v2)
‚úÖ /start ‚Äî –≤—ã–±–æ—Ä –∑–Ω–∞–∫–∞
‚úÖ üìù –ì–æ—Ä–æ—Å–∫–æ–ø –Ω–∞ —Å–µ–≥–æ–¥–Ω—è ‚Äî —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –ª—é–±—ã–º —Ç–µ–∫—Å—Ç–æ–º –∏ —ç–º–æ–¥–∑–∏
‚úÖ üîÆ –¢–∞—Ä–æ –¥–Ω—è ‚Äî –æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω—ã–π –≤—ã–±–æ—Ä
‚úÖ üîî –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è ‚Äî –≤—ã–±–æ—Ä –≤—Ä–µ–º–µ–Ω–∏ (06‚Äì10)
‚úÖ SQLite ‚Äî —Å –∞–≤—Ç–æ-–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º –∫–æ–ª–æ–Ω–æ–∫
"""

import asyncio
import contextlib
import datetime as dt
import os
import random
import secrets
import sqlite3
import textwrap
from typing import Dict, Tuple, Optional, Set, Callable, Any

from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, executor, types
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton

# === ENV & BOT ===============================================================
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
TZ = os.getenv("TZ", "Europe/Madrid")
os.environ["TZ"] = TZ
if not BOT_TOKEN or len(BOT_TOKEN) < 20:
    raise SystemExit("‚ùå BOT_TOKEN –ø—É—Å—Ç –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω")

bot = Bot(token=BOT_TOKEN, parse_mode="HTML")
dp = Dispatcher(bot)

# === DATABASE ================================================================
DB_PATH = os.path.join(os.path.dirname(__file__), "astrobot.db")

def db_connect(): return sqlite3.connect(DB_PATH)

def db_init():
    with db_connect() as cn:
        cn.execute("CREATE TABLE IF NOT EXISTS users (user_id INTEGER PRIMARY KEY, sign TEXT)")
        for col, ddl, default in [
            ("daily_enabled", "INTEGER DEFAULT 0", "0"),
            ("daily_hour", "INTEGER DEFAULT 9", "9"),
            ("daily_minute", "INTEGER DEFAULT 0", "0"),
            ("last_sent", "DATE", "NULL"),
        ]:
            cur = cn.execute(f"PRAGMA table_info(users)")
            names = [r[1] for r in cur.fetchall()]
            if col not in names:
                cn.execute(f"ALTER TABLE users ADD COLUMN {col} {ddl}")
                if default != "NULL":
                    cn.execute(f"UPDATE users SET {col}={default}")
        cn.commit()

db_init()

def get_user(uid: int):
    with db_connect() as cn:
        row = cn.execute("SELECT user_id, sign, daily_enabled, daily_hour, daily_minute, last_sent FROM users WHERE user_id=?", (uid,)).fetchone()
        return row

def upsert_user(uid: int):
    with db_connect() as cn:
        cn.execute("INSERT OR IGNORE INTO users (user_id) VALUES (?)", (uid,))
        cn.commit()

def set_sign(uid: int, sign: str):
    with db_connect() as cn:
        cn.execute("INSERT INTO users (user_id, sign) VALUES (?, ?) ON CONFLICT(user_id) DO UPDATE SET sign=excluded.sign", (uid, sign))
        cn.commit()

def set_daily(uid: int, en: bool):
    with db_connect() as cn:
        cn.execute("UPDATE users SET daily_enabled=? WHERE user_id=?", (1 if en else 0, uid))
        cn.commit()

def set_time(uid: int, h: int, m: int):
    with db_connect() as cn:
        cn.execute("UPDATE users SET daily_hour=?, daily_minute=? WHERE user_id=?", (h, m, uid))
        cn.commit()

def set_last_sent_today(uid: int, today: str):
    with db_connect() as cn:
        cn.execute("UPDATE users SET last_sent=? WHERE user_id=?", (today, uid))
        cn.commit()

def get_due_users(now: dt.datetime):
    with db_connect() as cn:
        today = now.date().isoformat()
        cur = cn.execute("""SELECT user_id, sign FROM users
                            WHERE daily_enabled=1 AND daily_hour=? AND daily_minute=? 
                            AND (last_sent IS NULL OR last_sent<>?) AND sign IS NOT NULL""",
                         (now.hour, now.minute, today))
        return cur.fetchall()

# === UI ======================================================================
SIGNS = [
    ("‚ôà –û–≤–µ–Ω", "aries"), ("‚ôâ –¢–µ–ª–µ—Ü", "taurus"), ("‚ôä –ë–ª–∏–∑–Ω–µ—Ü—ã", "gemini"),
    ("‚ôã –†–∞–∫", "cancer"), ("‚ôå –õ–µ–≤", "leo"), ("‚ôç –î–µ–≤–∞", "virgo"),
    ("‚ôé –í–µ—Å—ã", "libra"), ("‚ôè –°–∫–æ—Ä–ø–∏–æ–Ω", "scorpio"), ("‚ôê –°—Ç—Ä–µ–ª–µ—Ü", "sagittarius"),
    ("‚ôë –ö–æ–∑–µ—Ä–æ–≥", "capricorn"), ("‚ôí –í–æ–¥–æ–ª–µ–π", "aquarius"), ("‚ôì –†—ã–±—ã", "pisces")
]
SIGN_RU = {code: name for name, code in SIGNS}

def kb_signs():
    kb = InlineKeyboardMarkup(row_width=3)
    kb.add(*[InlineKeyboardButton(text=t, callback_data=f"sign|{c}") for t, c in SIGNS])
    return kb

def kb_main():
    kb = ReplyKeyboardMarkup(resize_keyboard=True)
    kb.add(KeyboardButton("üìù –ì–æ—Ä–æ—Å–∫–æ–ø –Ω–∞ —Å–µ–≥–æ–¥–Ω—è"), KeyboardButton("üîÆ –¢–∞—Ä–æ –¥–Ω—è"))
    kb.add(KeyboardButton("‚ôªÔ∏è –°–º–µ–Ω–∏—Ç—å –∑–Ω–∞–∫"))
    kb.add(KeyboardButton("üîî –í–∫–ª—é—á–∏—Ç—å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–µ"), KeyboardButton("üö´ –í—ã–∫–ª—é—á–∏—Ç—å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–µ"))
    kb.add(KeyboardButton("‚è∞ –ó–∞–¥–∞—Ç—å –≤—Ä–µ–º—è"))
    return kb

def kb_time_picker():
    kb = InlineKeyboardMarkup(row_width=3)
    for t in ["06:00", "07:00", "08:00", "09:00", "10:00"]:
        kb.insert(InlineKeyboardButton(t, callback_data=f"time|{t}"))
    return kb

# === TAROT ===================================================================
TAROT_SESSIONS: Dict[Tuple[int, str], bool] = {}
TAROT = {
    "1": "üåû <b>–°–æ–ª–Ω—Ü–µ</b> ‚Äî —Ä–∞–¥–æ—Å—Ç—å –∏ —É—Å–ø–µ—Ö.",
    "2": "üíñ <b>–í–ª—é–±–ª—ë–Ω–Ω—ã–µ</b> ‚Äî –≥–∞—Ä–º–æ–Ω–∏—è –∏ –≤—ã–±–æ—Ä —Å–µ—Ä–¥—Ü–µ–º.",
    "3": "üåà <b>–ú–∏—Ä</b> ‚Äî –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å."
}

def tarot_keyboard(sid: str):
    kb = InlineKeyboardMarkup(row_width=3)
    for i in ["1", "2", "3"]:
        kb.insert(InlineKeyboardButton(f"üÉè –ö–∞—Ä—Ç–∞ {i}", callback_data=f"tarot|{sid}|{i}"))
    return kb

@dp.callback_query_handler(lambda c: c.data.startswith("tarot|"))
async def tarot_pick(c: types.CallbackQuery):
    _, sid, cid = c.data.split("|")
    key = (c.message.chat.id, sid)
    if not TAROT_SESSIONS.get(key):
        return await c.answer("–≠—Ç–∞ —Ä–∞—Å–∫–ª–∞–¥–∫–∞ —É–∂–µ –∑–∞–∫—Ä—ã—Ç–∞.", show_alert=True)
    TAROT_SESSIONS[key] = False
    await c.answer("–ö–∞—Ä—Ç–∞ –≤—ã–±—Ä–∞–Ω–∞!")
    await bot.edit_message_text(f"üîÆ <b>–¢–∞—Ä–æ –¥–Ω—è</b>\n\n–¢—ã –≤—ã–±—Ä–∞–ª <b>–ö–∞—Ä—Ç—É {cid}</b>.\n\n{TAROT[cid]}",
                                c.message.chat.id, c.message.message_id)

# === HOROSCOPE ===============================================================
QUOTES = [
    "¬´–£–¥–∞—á–∞ –ª—é–±–∏—Ç —Å–º–µ–ª—ã—Ö.¬ª", "¬´–¢–µ—Ä–ø–µ–Ω–∏–µ ‚Äî —Ç–≤–æ–π –∫–æ–∑—ã—Ä—å.¬ª",
    "¬´–§–æ–∫—É—Å–∏—Ä—É–π—Å—è –Ω–∞ –≥–ª–∞–≤–Ω–æ–º.¬ª", "¬´–°–ª–æ–≤–∞ –æ–±–ª–∞–¥–∞—é—Ç —Å–∏–ª–æ–π.¬ª"
]
COLORS = ["–∫—Ä–∞—Å–Ω—ã–π","—Å–∏–Ω–∏–π","–∑–µ–ª—ë–Ω—ã–π","–∑–æ–ª–æ—Ç–æ–π","—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π","–±–∏—Ä—é–∑–æ–≤—ã–π","—è–Ω—Ç–∞—Ä–Ω—ã–π","–∞–ª—ã–π","–Ω–µ–±–µ—Å–Ω—ã–π","–∏–∑—É–º—Ä—É–¥–Ω—ã–π"]

def generate_horoscope(sign: str):
    rnd = random.Random(hash((sign, dt.date.today().toordinal())))
    return textwrap.dedent(f"""
    <b>{SIGN_RU.get(sign, sign)}</b> ‚Äî –≥–æ—Ä–æ—Å–∫–æ–ø –Ω–∞ —Å–µ–≥–æ–¥–Ω—è

    üíñ –õ—é–±–æ–≤—å: {rnd.choice(['–ø—Ä–∏—è—Ç–Ω—ã–π —Å—é—Ä–ø—Ä–∏–∑','–Ω–æ–≤–æ–µ –∑–Ω–∞–∫–æ–º—Å—Ç–≤–æ','–≥–∞—Ä–º–æ–Ω–∏—è'])}
    üíº –†–∞–±–æ—Ç–∞: {rnd.choice(['—É—Å–ø–µ—à–Ω—ã–µ –ø–µ—Ä–µ–≥–æ–≤–æ—Ä—ã','–≤–¥–æ—Ö–Ω–æ–≤–µ–Ω–∏–µ','—á—ë—Ç–∫–∏–π –ø–ª–∞–Ω'])}
    üí∞ –î–µ–Ω—å–≥–∏: {rnd.choice(['–ø—Ä–∏—è—Ç–Ω—ã–π –±–æ–Ω—É—Å','—É–º–µ—Ä–µ–Ω–Ω—ã–µ —Ç—Ä–∞—Ç—ã','—É–¥–∞—á–Ω–∞—è —Å–¥–µ–ª–∫–∞'])}
    üåø –ó–¥–æ—Ä–æ–≤—å–µ: {rnd.choice(['—ç–Ω–µ—Ä–≥–∏—è','—Å–ø–æ–∫–æ–π—Å—Ç–≤–∏–µ','—Ö–æ—Ä–æ—à–∏–π —Å–æ–Ω'])}
    üéØ –°–æ–≤–µ—Ç: {rnd.choice(['–±—É–¥—å —Å–ø–æ–∫–æ–µ–Ω','–¥–æ–≤–µ—Ä—å—Å—è –∏–Ω—Ç—É–∏—Ü–∏–∏','–Ω–∞—Å–ª–∞–∂–¥–∞–π—Å—è –º–æ–º–µ–Ω—Ç–æ–º'])}
    üé® –¶–≤–µ—Ç: {rnd.choice(COLORS)}

    {rnd.choice(QUOTES)}
    """).strip()

# === HANDLERS ================================================================
@dp.message_handler(commands=["start"])
async def start(m: types.Message):
    upsert_user(m.from_user.id)
    await m.answer("‚ú® –ü—Ä–∏–≤–µ—Ç! –Ø <b>AstroBot</b>.\n–í—ã–±–µ—Ä–∏ —Å–≤–æ–π –∑–Ω–∞–∫ –∑–æ–¥–∏–∞–∫–∞:", reply_markup=kb_signs())

@dp.callback_query_handler(lambda c: c.data.startswith("sign|"))
async def pick_sign(c: types.CallbackQuery):
    _, code = c.data.split("|")
    set_sign(c.from_user.id, code)
    await c.answer("–ó–Ω–∞–∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω!")
    await bot.send_message(c.message.chat.id, f"–ó–Ω–∞–∫ <b>{SIGN_RU[code]}</b> —Å–æ—Ö—Ä–∞–Ω—ë–Ω ‚úÖ", reply_markup=kb_main())

# --- –ì–æ—Ä–æ—Å–∫–æ–ø (—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ —Ä–µ–∞–≥–∏—Ä—É–µ—Ç) ---
@dp.message_handler(lambda m: m.text and ("–≥–æ—Ä–æ—Å–∫–æ–ø" in m.text.lower() or "üìù" in m.text))
@dp.message_handler(commands=["today"])
async def today(m: types.Message):
    row = get_user(m.from_user.id)
    if not row or not row[1]:
        return await m.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –∑–Ω–∞–∫:", reply_markup=kb_signs())
    sign = row[1]
    await m.answer(generate_horoscope(sign), reply_markup=kb_main())

# --- –¢–∞—Ä–æ ---
@dp.message_handler(lambda m: m.text and "üîÆ" in m.text)
async def tarot_cmd(m: types.Message):
    sid = secrets.token_hex(4)
    TAROT_SESSIONS[(m.chat.id, sid)] = True
    await m.answer("üîÆ <b>–¢–∞—Ä–æ –¥–Ω—è</b>\n–í—ã–±–µ—Ä–∏ –æ–¥–Ω—É –∫–∞—Ä—Ç—É:", reply_markup=tarot_keyboard(sid))

# --- –°–º–µ–Ω–∞ –∑–Ω–∞–∫–∞ ---
@dp.message_handler(lambda m: m.text and "‚ôªÔ∏è" in m.text)
async def change_sign(m: types.Message):
    await m.answer("–í—ã–±–µ—Ä–∏ –Ω–æ–≤—ã–π –∑–Ω–∞–∫:", reply_markup=kb_signs())

# --- –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è ---
@dp.message_handler(lambda m: m.text and "üîî" in m.text)
async def daily_on(m: types.Message):
    await m.answer("–í—ã–±–µ—Ä–∏ –≤—Ä–µ–º—è —Ä–∞—Å—Å—ã–ª–∫–∏:", reply_markup=kb_time_picker())

@dp.callback_query_handler(lambda c: c.data.startswith("time|"))
async def pick_time(c: types.CallbackQuery):
    _, t = c.data.split("|")
    h, m_ = map(int, t.split(":"))
    set_time(c.from_user.id, h, m_)
    set_daily(c.from_user.id, True)
    await c.answer("–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –≤–∫–ª—é—á–µ–Ω—ã!")
    await bot.send_message(c.message.chat.id, f"üîî –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –≤–∫–ª—é—á–µ–Ω—ã –Ω–∞ {t}", reply_markup=kb_main())

@dp.message_handler(lambda m: m.text and "üö´" in m.text)
async def daily_off(m: types.Message):
    set_daily(m.from_user.id, False)
    await m.answer("üö´ –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –æ—Ç–∫–ª—é—á–µ–Ω—ã.", reply_markup=kb_main())

# --- –í—Ä–µ–º—è ---
@dp.message_handler(lambda m: m.text and "‚è∞" in m.text)
async def show_time(m: types.Message):
    row = get_user(m.from_user.id)
    if not row:
        upsert_user(m.from_user.id)
        row = get_user(m.from_user.id)
    _, _, en, hh, mm, _ = row
    await m.answer(f"‚è∞ –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è —Ä–∞—Å—Å—ã–ª–∫–∏: {hh:02d}:{mm:02d} ({'–≤–∫–ª' if en else '–≤—ã–∫–ª'})", reply_markup=kb_main())

# --- –§–æ–ª–±—ç–∫ ---
@dp.message_handler()
async def fallback(m: types.Message):
    await m.answer("–î–æ—Å—Ç—É–ø–Ω–æ:\n‚Ä¢ /start\n‚Ä¢ üìù –ì–æ—Ä–æ—Å–∫–æ–ø –Ω–∞ —Å–µ–≥–æ–¥–Ω—è\n‚Ä¢ üîÆ –¢–∞—Ä–æ –¥–Ω—è\n‚Ä¢ üîî –í–∫–ª—é—á–∏—Ç—å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–µ\n‚Ä¢ ‚ôªÔ∏è –°–º–µ–Ω–∏—Ç—å –∑–Ω–∞–∫", reply_markup=kb_main())

# === SCHEDULER ===============================================================
async def scheduler_loop():
    await asyncio.sleep(2)
    while True:
        now = dt.datetime.now()
        for uid, sign in get_due_users(now):
            with contextlib.suppress(Exception):
                await bot.send_message(uid, generate_horoscope(sign))
                set_last_sent_today(uid, now.date().isoformat())
        await asyncio.sleep(60)

async def on_startup(_):
    asyncio.create_task(scheduler_loop())

if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True, on_startup=on_startup)

